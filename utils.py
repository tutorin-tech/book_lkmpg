"""The module contains utils to convert and deploy the book."""

import logging
import os
import re
from collections import OrderedDict
from pathlib import Path

import requests

URL = os.getenv('URL', 'http://127.0.0.1:8004/w/api.php')
MEDIA_WIKI_PASSWORD = os.getenv('MEDIA_WIKI_PASSWORD', 'admin00000')
MEDIA_WIKI_USERNAME = os.getenv('MEDIA_WIKI_USERNAME', 'admin')

DEFAULT_FILE = 'lkmpg_chunked.tex'

BOOK_NAMESPACE = 'Book:lkmpg'

LOGGER = logging.getLogger(__name__)

#
# MediaWiki API
#

session = requests.Session()


def append_text(title, text):
    """Append the passed text to the page, keeping previous text."""
    return session.post(
        URL, data={
            'action': 'edit',
            'token': get_csrf_token(),
            'format': 'json',
            'formatversion': 2,
            'title': title,
            'appendtext': text,
        },
    )


def get_csrf_token():
    """Log in and return the CSRF token."""
    login_token = session.get(
        URL, params={
            'action': 'query',
            'meta': 'tokens',
            'type': 'login',
            'format': 'json',
        },
    ).json()['query']['tokens']['logintoken']

    session.post(
        URL, data={
            'action': 'login',
            'lgname': MEDIA_WIKI_USERNAME,
            'lgpassword': MEDIA_WIKI_PASSWORD,
            'lgtoken': login_token,
            'format': 'json',
        },
    )

    return session.get(
        URL, params={
            'action': 'query',
            'meta': 'tokens',
            'format': 'json',
        },
    ).json()['query']['tokens']['csrftoken']


def upload_page(title, text):
    """Upload the passed text to the page, rewriting previous text."""
    return session.post(
        URL, data={
            'action': 'edit',
            'token': get_csrf_token(),
            'format': 'json',
            'formatversion': 2,
            'title': title,
            'text': text,
        },
    )


def upload_file(path):
    """Upload a file by the passed path."""
    return session.post(
        URL, data={
            'action': 'upload',
            'filename': path.split('/')[-1],
            'token': get_csrf_token(),
            'format': 'json',
            'ignorewarnings': 1,
        }, files={'file': (path.split('/')[-1], Path(path).open('rb'), 'multipart/form-data')},
    )


#
# Utils
#


def _extract_images_paths(filenames):
    """Extract and return images paths from the passed files."""
    image_paths = []
    for filename in filenames:
        matches = re.findall(r'\[\[File:([^|\]]+)', Path(filename).read_text(encoding='utf-8'))
        if matches:
            image_paths.extend([f'html/{match}' for match in matches])

    return set(image_paths)


def _extract_titles_with_labels(content):
    """Extract and return the titles with their labels from the passed file."""

    def fix_title(title):
        return title.replace('\\', '').replace("'", '’')

    sections = OrderedDict()
    current_section = None

    lines = content.split('\n')
    for line in lines:
        section_match = re.search(r'\\section\{(.*?)\}', line)
        if section_match:
            section_title = fix_title(section_match.group(1))
            label_match = re.search(r'\\label\{(.*?)\}', lines[lines.index(line) + 1])
            sections[section_title] = {
                'label': label_match.group(1) if label_match else '',
                'subsections': OrderedDict(),
            }
            current_section = section_title
        elif current_section:
            subsection_match = re.search(r'\\subsection\{(.*?)\}', line)
            if subsection_match:
                subsection_title = fix_title(subsection_match.group(1))
                label_match = re.search(r'\\label\{(.*?)\}', lines[lines.index(line) + 1])
                sections[current_section]['subsections'][subsection_title] = {
                    'label': label_match.group(1) if label_match else '',
                }

    return sections


def _get_link(page, anchor=''):
    """Return the link built by the passed page name."""
    return f'{BOOK_NAMESPACE}/{page}{anchor}'


def _generate_toc(sections):
    """Return TOC generated by the passed sections titles."""
    toc_lines = ['<h2>Table of Contents</h2>\n\n<div class="tableofcontents">\n']
    for i, (section, section_data) in enumerate(sections.items(), 1):
        toc_lines.append(
            f' <span class="sectionToc">{i} [[{_get_link(section)}|{section}]]</span><br />\n',
        )
        for j, subsection in enumerate(section_data['subsections'], 1):
            toc_lines.append(
                f'  <span class="subsectionToc">{i}.{j} '
                f'[[{_get_link(section, f"#{i}.{j}_{subsection}")}|{subsection}]]</span><br />\n',
            )

    toc_lines.append('</div>\n\n')
    return ''.join(toc_lines)


def _replace_refs(content, label_dict):
    """Replace the Latex reference format with the Mediawiki references format."""

    def replacement(match):
        label = match.group(1)
        for i, (section_title, section_data) in enumerate(label_dict.items(), 1):
            if section_data['label'] == label:
                return f'[[{_get_link(section_title)}|{section_title}]]'

            for j, (sub_title, sub_data) in enumerate(section_data['subsections'].items(), 1):
                if sub_data['label'] == label:
                    anchor = rf'\#{i}.{j}_{sub_title}|{sub_title}'
                    return (
                        f'[[{_get_link(section_title, anchor).replace(" ", "_")}|'
                        f'{sub_title}]]')

        return match.group(0)

    return re.sub(r'\\ref\{(.*?)\}', replacement, content)


#
# Public functions
#

def deploy_book(*wiki_files, filename='lkmpg.tex'):
    """Deploy the book to Mediawiki."""
    # Common styles
    upload_page('MediaWiki:Common.css', Path('wiki.css').read_text(encoding='utf-8'))

    # BookCard template
    upload_page('Template:BookCard', Path('template_book_card.wiki').read_text(encoding='utf-8'))
    upload_page('Module:BookCard', Path('module_book_card.lua').read_text(encoding='utf-8'))

    # NavigationArrows template
    upload_page(
        'Module:NavigationArrows',
        Path('module_navigation_arrows.lua').read_text(encoding='utf-8'),
    )
    upload_page(
        'Template:NavigationArrows',
        Path('template_navigation_arrows.wiki').read_text(encoding='utf-8'),
    )

    # Translations
    upload_page('MediaWiki:additional_info', 'Additional info')
    upload_page('MediaWiki:additional_info/ru', 'Дополнительная информация')
    upload_page('MediaWiki:authors', 'Authors')
    upload_page('MediaWiki:authors/ru', 'Авторы')
    upload_page('MediaWiki:english', 'English')
    upload_page('MediaWiki:english/ru', 'Английский')
    upload_page('MediaWiki:language', 'Language')
    upload_page('MediaWiki:language/ru', 'Язык')
    upload_page('MediaWiki:next_chapter', 'next chapter')
    upload_page('MediaWiki:next_chapter/ru', 'следующая глава')
    upload_page('MediaWiki:prev_chapter', 'previous chapter')
    upload_page('MediaWiki:prev_chapter/ru', 'предыдущая глава')
    upload_page('MediaWiki:publication_date', 'Publication date')
    upload_page('MediaWiki:publication_date/ru', 'Дата публикации')
    upload_page('MediaWiki:sections', 'Sections')
    upload_page('MediaWiki:sections/ru', 'Секции')

    _preprocess_wiki_files(*wiki_files)

    # Upload images
    images_paths = _extract_images_paths(wiki_files)
    for image_path in images_paths:
        response = upload_file(image_path)

        if response.json().get('error'):
            LOGGER.warning(
                'Error has occurred while loading the %s file: %s',
                image_path, response.json()['error']['info'],
            )
        else:
            LOGGER.info('File %s has been loaded', image_path)

    # Upload pages
    titles = _extract_titles_with_labels(Path(filename).read_text(encoding='utf-8'))
    for wiki_file, title in zip(wiki_files, titles, strict=True):
        title_link = _get_link(title)
        response = upload_page(title_link, Path(wiki_file).read_text(encoding='utf-8'))

        if response.json().get('error'):
            LOGGER.warning(
                'Error has occurred while deploying the %s page: %s',
                title_link, response.json()['error']['info'],
            )
        else:
            LOGGER.info('Page %s has been deployed', title_link)

    # In process of deploying the pages some of them are linked to yet non-existing
    # ones, that colors them in red. To fix it we need to update them after deploying
    for title in titles:
        append_text(_get_link(title), '')


def preprocess_tex_file(filename, output_dir='chunked_tex'):
    """Split the main TEX file into files by sections and locate them
    into the directory.
    """
    Path(output_dir).mkdir(exist_ok=True)

    content = Path(filename).read_text(encoding='utf-8')
    content_by_sections = re.split(r'(\\section\{[^}]*\})', content)
    sections = content_by_sections[1:]

    titles_with_labels = _extract_titles_with_labels(content)
    for i in range(0, len(sections), 2):
        with Path(
            Path(output_dir) / Path(f'{i // 2 + 1:02d}.tex'),
        ).open('w', encoding='utf-8') as file:
            file.write(content_by_sections[0])  # preamble
            file.write(rf'\setcounter{{section}}{{{i // 2}}}' + '\n')
            file.write(sections[i])  # section header
            file.write(_replace_refs(
                sections[i + 1] if i + 1 < len(sections) else '',  # section content
                titles_with_labels,
            ))
            file.write(r'\end{document}')


def _preprocess_wiki_files(*wiki_files, filename='lkmpg.tex'):
    """Add navigation elements to each page and the book card and the TOC to the first one."""
    titles_data = _extract_titles_with_labels(Path(filename).read_text(encoding='utf-8'))
    titles = list(titles_data.keys())

    navigation_template = Path('navigation_arrows.wiki').read_text(encoding='utf-8')
    book_card = Path('book_card.wiki').read_text(encoding='utf-8')

    for i, wiki_file in enumerate(wiki_files):
        prev_chapter_link = _get_link(titles[max(i - 1, 0)])
        next_chapter_link = _get_link(titles[min(i + 1, len(wiki_files) - 1)])

        content = re.sub(
            r'<code>\s*</code>', '', Path(wiki_file).read_text(
                encoding='utf-8',
            ).replace(r'<code> <\/code>', '').replace('&quot;', '"'),
        )
        with Path(wiki_file).open('w', encoding='utf-8') as file:
            file.write(navigation_template.format(
                prev_chapter_link=prev_chapter_link,
                next_chapter_link=next_chapter_link,
            ))
            if not i:  # add the book card to the first page
                file.write(book_card)

            file.write(content)
            if not i:  # add the TOC to the first page
                file.write(_generate_toc(titles_data))

            file.write(navigation_template.format(
                prev_chapter_link=prev_chapter_link,
                next_chapter_link=next_chapter_link,
            ))
